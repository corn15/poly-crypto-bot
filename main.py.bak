import datetime
import json
import threading
import time

import pytz
import requests
import schedule

from ts_convert import to_est_format

pm_to_bn = {"bitcoin": "BTCUSDT", "ethereum": "ETHUSDT"}


class CryptoPredictionBot:
    def __init__(self):
        self.opening_prices = {}
        self.current_prices = {}
        self.clob_token_ids = {}
        self.token_prices = {}
        self.initialized = False

    def get_hour_start_timestamp(self):
        """è·å–å½“å‰æ•´ç‚¹çš„æ—¶é—´æˆ³"""
        now = datetime.datetime.now(pytz.timezone("America/New_York"))
        hour_start = now.replace(minute=0, second=0, microsecond=0)
        return int(hour_start.timestamp() * 1000)  # è½¬æ¢ä¸ºæ¯«ç§’

    # def get_binance_opening_price(self, symbol, start_time):
    #     """è·å–Binanceå¼€ç›˜ä»·æ ¼"""
    #     try:
    #         url = f"https://api.binance.com/api/v3/klines"
    #         params = {
    #             'symbol': symbol,
    #             'interval': '1h',
    #             'startTime': start_time,
    #             'limit': 1
    #         }
    #         response = requests.get(url, params=params, timeout=10)
    #         response.raise_for_status()
    #         data = response.json()

    #         if data:
    #             opening_price = float(data[0][1])  # å¼€ç›˜ä»·åœ¨ç´¢å¼•1
    #             print(f"âœ… {symbol} å¼€ç›˜ä»·: {opening_price}")
    #             return opening_price
    #         return None
    #     except Exception as e:
    #         print(f"âŒ è·å–{symbol}å¼€ç›˜ä»·å¤±è´¥: {e}")
    #         return None

    # def get_crypto_price(self, symbol, time):
    #     try:
    #         url = f"https://polymarket.com/api/crypto/crypto-price/"
    #         params = {
    #             'symbol': symbol,
    #             'eventStartTime': time,
    #             'variant': 'hourly',
    #             'endDate': time
    #         }

    #         response = requests.get(url, params=params, timeout=10)
    #         response.raise_for_status()
    #         data = response.json()
    #         if data:
    #             price = float(data.get('openPrice', 0))
    #             print(f"âœ… {symbol} åŠ å¯†è²¨å¹£åƒ¹æ ¼: {price}")
    #             return price
    #         return None
    #     except Exception as e:
    #         print(f"âŒ ç²å–{symbol}åŠ å¯†è²¨å¹£åƒ¹æ ¼å¤±æ•—: {e}")
    #         return None

    def get_polymarket_tokens(self, crypto_name):
        """è·å–Polymarketå¸‚åœºçš„tokenä¿¡æ¯"""
        try:
            # è·å–å½“å‰æ—¶é—´çš„ESTæ ¼å¼
            current_timestamp = int(time.time())
            time_format = to_est_format(current_timestamp)

            # æ„å»ºURL
            slug = f"{crypto_name}-up-or-down-{time_format}"
            url = "https://gamma-api.polymarket.com/markets"
            params = {"slug": slug}

            print(f"ğŸ” æœå°‹ Polymarket å¸‚å ´: {slug}")
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            if data and len(data) > 0:
                clob_token_ids = json.loads(data[0].get("clobTokenIds", []))
                market_title = data[0].get("question", "Unknown")
                print(f"âœ… æ‰¾åˆ°å¸‚å ´: {market_title}")
                print(clob_token_ids)
                if len(clob_token_ids) >= 2:
                    print(clob_token_ids[0])
                    print(clob_token_ids[1])
                    up_token = clob_token_ids[0]
                    down_token = clob_token_ids[1]
                    print(f" up_token: {up_token}")
                    print(f" down_token: {down_token}")
                    return {"up": up_token, "down": down_token}
                else:
                    print("âš ï¸  å¸‚å ´æ²’æœ‰è¶³å¤ çš„ token")
            else:
                print(f"âŒ æ²’æœ‰æ‰¾åˆ°ç›¸æ‡‰çš„å¸‚å ´: {slug}")
            return None
        except Exception as e:
            print(f"âŒ è·å–{crypto_name} Polymarket tokenså¤±è´¥: {e}")
            return None

    def get_binance_current_price(self, symbol):
        """è·å–Binanceå½“å‰ä»·æ ¼"""
        try:
            url = "https://api.binance.com/api/v3/ticker/price"
            params = {"symbol": symbol}
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            current_price = float(data["price"])
            return current_price
        except Exception as e:
            print(f"âŒ è·å–{symbol}å½“å‰ä»·æ ¼å¤±è´¥: {e}")
            return None

    def get_polymarket_token_price(self, token_id):
        """è·å–Polymarket tokenä»·æ ¼"""
        try:
            url = "https://clob.polymarket.com/price"
            params = {"token_id": token_id, "side": "buy"}
            response = requests.get(url, params=params, timeout=10)

            if response.status_code == 404:
                # Token æ²’æœ‰è¨‚å–®ç°¿æ˜¯å¸¸è¦‹çš„æƒ…æ³
                return None

            response.raise_for_status()
            data = response.json()

            price = float(data.get("price", 0))
            return price
        except Exception as e:
            print(f"âš ï¸  Token {token_id[:20]}... åƒ¹æ ¼ç²å–å¤±æ•—: {e}")
            return None

    def initialize_data(self):
        """åˆå§‹åŒ–æ•°æ® - åœ¨æ•´ç‚¹å30ç§’æ‰§è¡Œ"""
        print("\n" + "=" * 50)
        print("ğŸš€ åˆå§‹åŒ–æ•¸æ“š")
        print("=" * 50)
        hour_start = self.get_hour_start_timestamp()

        # è·å–å¼€ç›˜ä»·æ ¼
        for crypto_name, symbol in pm_to_bn.items():
            print(f"\nğŸ“Š è™•ç† {crypto_name.upper()}...")

            opening_price = self.get_binance_opening_price(symbol, hour_start)
            if opening_price:
                self.opening_prices[crypto_name] = opening_price

            # è·å–Polymarket tokens
            tokens = self.get_polymarket_tokens(crypto_name)
            if tokens:
                self.clob_token_ids[crypto_name] = tokens

        self.initialized = True
        print("\nâœ… åˆå§‹åŒ–å®Œæˆï¼")

    def update_prices(self):
        """æ›´æ–°ä»·æ ¼ - æ¯åˆ†é’Ÿæ‰§è¡Œ"""
        if not self.initialized:
            print("âš ï¸  å°šæœªåˆå§‹åŒ–ï¼Œè·³éåƒ¹æ ¼æ›´æ–°")
            return

        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        print(f"\nğŸ“ˆ [{current_time}] æ›´æ–°åƒ¹æ ¼...")

        # æ›´æ–°Binanceä»·æ ¼
        for crypto_name, symbol in pm_to_bn.items():
            current_price = self.get_binance_current_price(symbol)
            if current_price:
                self.current_prices[crypto_name] = current_price

        # æ›´æ–°Polymarket tokenä»·æ ¼
        for crypto_name, tokens in self.clob_token_ids.items():
            if crypto_name not in self.token_prices:
                self.token_prices[crypto_name] = {}
            for direction, token_id in tokens.items():
                price = self.get_polymarket_token_price(token_id)
                if price:
                    self.token_prices[crypto_name][direction] = price

        # æ˜¾ç¤ºå½“å‰çŠ¶æ€
        self.display_status()

    def display_status(self):
        """æ˜¾ç¤ºå½“å‰çŠ¶æ€"""
        print("\n" + "=" * 30 + " ç•¶å‰ç‹€æ…‹ " + "=" * 30)

        for crypto_name in pm_to_bn.keys():
            print(f"\nğŸª™ {crypto_name.upper()}:")

            if crypto_name in self.opening_prices:
                opening = self.opening_prices[crypto_name]
                print(f"  ğŸ é–‹ç›¤åƒ¹: ${opening:,.2f}")

            if crypto_name in self.current_prices:
                current = self.current_prices[crypto_name]
                opening = self.opening_prices.get(crypto_name, 0)

                if opening > 0:
                    change = ((current - opening) / opening) * 100
                    if change > 0:
                        direction_emoji = "ğŸ“ˆ"
                        direction_text = "ä¸Šæ¼²"
                        color = "ğŸŸ¢"
                    elif change < 0:
                        direction_emoji = "ğŸ“‰"
                        direction_text = "ä¸‹è·Œ"
                        color = "ğŸ”´"
                    else:
                        direction_emoji = "â¡ï¸"
                        direction_text = "æŒå¹³"
                        color = "ğŸŸ¡"
                    print(
                        f"  ğŸ’° ç•¶å‰åƒ¹: ${current:,.2f} {direction_emoji} {color} {direction_text} {abs(change):.2f}%"
                    )
                else:
                    print(f"  ğŸ’° ç•¶å‰åƒ¹: ${current:,.2f}")

            if crypto_name in self.token_prices:
                tokens = self.token_prices[crypto_name]
                print("  ğŸ¯ Polymarket åƒ¹æ ¼:")
                if "up" in tokens:
                    print(f"     ğŸ“ˆ UP Token: ${tokens['up']:.3f}")
                if "down" in tokens:
                    print(f"     ğŸ“‰ DOWN Token: ${tokens['down']:.3f}")
                # è¨ˆç®—éš±å«æ©Ÿç‡
                if "up" in tokens and "down" in tokens:
                    up_price = tokens["up"]
                    down_price = tokens["down"]
                    total = up_price + down_price
                    if total > 0:
                        up_prob = (up_price / total) * 100
                        down_prob = (down_price / total) * 100
                        print(f"     ğŸ² éš±å«æ©Ÿç‡: UP {up_prob:.1f}% | DOWN {down_prob:.1f}%")
            else:
                print("  âš ï¸  Polymarket åƒ¹æ ¼æš«ä¸å¯ç”¨")

        print("=" * 70)

    def wait_for_next_initialization(self):
        """ç­‰å¾…åˆ°ä¸‹ä¸€å€‹æ•´é»å¾Œ30ç§’ï¼Œæˆ–ç«‹å³åŸ·è¡Œå¦‚æœå·²ç¶“éäº†30ç§’"""
        now = datetime.datetime.now()

        # æª¢æŸ¥æ˜¯å¦å·²ç¶“éäº†ç•¶å‰æ•´é»çš„30ç§’
        if now.minute > 0 or (now.minute == 0 and now.second >= 30):
            # å¦‚æœå·²ç¶“éäº†30ç§’ï¼Œç«‹å³åŸ·è¡Œåˆå§‹åŒ–
            print(f"âš¡ ç•¶å‰æ™‚é–“ {now.strftime('%H:%M:%S')} å·²éæ•´é»30ç§’ï¼Œç«‹å³åŸ·è¡Œåˆå§‹åŒ–...")
            self.initialize_data()
            return

        # å¦å‰‡ç­‰å¾…åˆ°ç•¶å‰å°æ™‚çš„30ç§’
        while True:
            now = datetime.datetime.now()
            target_time = now.replace(minute=0, second=30, microsecond=0)

            wait_seconds = (target_time - now).total_seconds()

            if wait_seconds <= 0:
                self.initialize_data()
                break
            else:
                print(f"â° ç­‰å¾… {wait_seconds:.0f} ç§’åˆ°æ•´é»å¾Œ30ç§’é€²è¡Œåˆå§‹åŒ–...")
                time.sleep(min(wait_seconds, 60))  # æœ€å¤šç­‰å¾…60ç§’ï¼Œç„¶å¾Œé‡æ–°æª¢æŸ¥

    def start(self):
        """å¯åŠ¨æœºå™¨äºº"""
        print("ğŸ¤– å•Ÿå‹•åŠ å¯†è²¨å¹£é æ¸¬æ©Ÿå™¨äºº...")
        print("ğŸ“‹ ç›£æ§: BTC/USDT, ETH/USDT")
        print("ğŸ• åˆå§‹åŒ–: æ¯å°æ™‚æ•´é»å¾Œ30ç§’")
        print("ğŸ“Š åƒ¹æ ¼æ›´æ–°: æ¯åˆ†é˜")
        print("-" * 50)

        # è®¾ç½®å®šæ—¶ä»»åŠ¡ - æ¯åˆ†é˜æ›´æ–°åƒ¹æ ¼
        schedule.every().minute.at(":00").do(self.update_prices)

        # åœ¨å–®ç¨ç·šç¨‹ä¸­ç­‰å¾…åˆå§‹åŒ–
        def wait_and_init():
            self.wait_for_next_initialization()

        init_thread = threading.Thread(target=wait_and_init)
        init_thread.daemon = True
        init_thread.start()

        # ä¸»å¾ªç’°
        try:
            while True:
                schedule.run_pending()
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nğŸ‘‹ æ©Ÿå™¨äººå·²åœæ­¢")


def main():
    bot = CryptoPredictionBot()
    bot.get_crypto_price("BTC", "2025-08-20T00:00:00Z")
    # bot.start()


if __name__ == "__main__":
    main()
